{"version":3,"file":"gluon.es5.js","sources":["node_modules/lit-html/lib/template.js","node_modules/lit-html/lib/modify-template.js","node_modules/lit-html/lib/dom.js","node_modules/lit-html/lib/directive.js","node_modules/lit-html/lib/part.js","node_modules/lit-html/lib/template-instance.js","node_modules/lit-html/lib/template-result.js","node_modules/lit-html/lib/parts.js","node_modules/lit-html/lib/template-factory.js","node_modules/lit-html/lib/render.js","node_modules/lit-html/lib/default-template-processor.js","node_modules/lit-html/lit-html.js","node_modules/lit-html/lib/shady-render.js","src/gluon.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, not attribute positions,\n * in template.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\nexport const rewritesStyleAttribute = (() => {\n    const el = document.createElement('div');\n    el.setAttribute('style', '{{bad value}}');\n    return el.getAttribute('style') !== '{{bad value}}';\n})();\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        const _prepareTemplate = (template) => {\n            const content = template.content;\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                   NodeFilter.SHOW_TEXT */, null, false);\n            // The actual previous node, accounting for removals: if a node is removed\n            // it will never be the previousNode.\n            let previousNode;\n            // Used to set previousNode at the top of the loop.\n            let currentNode;\n            while (walker.nextNode()) {\n                index++;\n                previousNode = currentNode;\n                const node = currentNode = walker.currentNode;\n                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                    if (node.hasAttributes()) {\n                        const attributes = node.attributes;\n                        // Per\n                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                        // attributes are not guaranteed to be returned in document order.\n                        // In particular, Edge/IE can return them out of order, so we cannot\n                        // assume a correspondance between part index and attribute index.\n                        let count = 0;\n                        for (let i = 0; i < attributes.length; i++) {\n                            if (attributes[i].value.indexOf(marker) >= 0) {\n                                count++;\n                            }\n                        }\n                        while (count-- > 0) {\n                            // Get the template literal section leading up to the first\n                            // expression in this attribute\n                            const stringForPart = result.strings[partIndex];\n                            // Find the attribute name\n                            const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                            // Find the corresponding attribute\n                            // If the attribute name contains special characters, lower-case\n                            // it so that on XML nodes with case-sensitive getAttribute() we\n                            // can still find the attribute, which will have been lower-cased\n                            // by the parser.\n                            //\n                            // If the attribute name doesn't contain special character, it's\n                            // important to _not_ lower-case it, in case the name is\n                            // case-sensitive, like with XML attributes like \"viewBox\".\n                            const attributeLookupName = (rewritesStyleAttribute && name === 'style') ?\n                                'style$' :\n                                /^[a-zA-Z-]*$/.test(name) ? name : name.toLowerCase();\n                            const attributeValue = node.getAttribute(attributeLookupName);\n                            const strings = attributeValue.split(markerRegex);\n                            this.parts.push({ type: 'attribute', index, name, strings });\n                            node.removeAttribute(attributeLookupName);\n                            partIndex += strings.length - 1;\n                        }\n                    }\n                    if (node.tagName === 'TEMPLATE') {\n                        _prepareTemplate(node);\n                    }\n                }\n                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                    const nodeValue = node.nodeValue;\n                    if (nodeValue.indexOf(marker) < 0) {\n                        continue;\n                    }\n                    const parent = node.parentNode;\n                    const strings = nodeValue.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore((strings[i] === '') ? createMarker() :\n                            document.createTextNode(strings[i]), node);\n                        this.parts.push({ type: 'node', index: index++ });\n                    }\n                    parent.insertBefore(strings[lastIndex] === '' ?\n                        createMarker() :\n                        document.createTextNode(strings[lastIndex]), node);\n                    nodesToRemove.push(node);\n                }\n                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                    if (node.nodeValue === marker) {\n                        const parent = node.parentNode;\n                        // Add a new marker node to be the startNode of the Part if any of\n                        // the following are true:\n                        //  * We don't have a previousSibling\n                        //  * previousSibling is being removed (thus it's not the\n                        //    `previousNode`)\n                        //  * previousSibling is not a Text node\n                        //\n                        // TODO(justinfagnani): We should be able to use the previousNode\n                        // here as the marker node and reduce the number of extra nodes we\n                        // add to a template. See\n                        // https://github.com/PolymerLabs/lit-html/issues/147\n                        const previousSibling = node.previousSibling;\n                        if (previousSibling === null || previousSibling !== previousNode ||\n                            previousSibling.nodeType !== Node.TEXT_NODE) {\n                            parent.insertBefore(createMarker(), node);\n                        }\n                        else {\n                            index--;\n                        }\n                        this.parts.push({ type: 'node', index: index++ });\n                        nodesToRemove.push(node);\n                        // If we don't have a nextSibling add a marker node.\n                        // We don't have to check if the next node is going to be removed,\n                        // because that node will induce a new marker if so.\n                        if (node.nextSibling === null) {\n                            parent.insertBefore(createMarker(), node);\n                        }\n                        else {\n                            index--;\n                        }\n                        currentNode = previousNode;\n                        partIndex++;\n                    }\n                    else {\n                        let i = -1;\n                        while ((i = node.nodeValue.indexOf(marker, i + 1)) !== -1) {\n                            // Comment node has a binding marker inside, make an inactive part\n                            // The binding won't work, but subsequent bindings will\n                            // TODO (justinfagnani): consider whether it's even worth it to\n                            // make bindings in comments work\n                            this.parts.push({ type: 'node', index: -1 });\n                        }\n                    }\n                }\n            }\n        };\n        _prepareTemplate(element);\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isTemplatePartActive } from './template.js';\nconst walkerNodeFilter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let part = parts[partIndex];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we're removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            // go to the next active part.\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n            part = parts[partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) ? 0 : 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there's no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            insertCount = countNodes(node);\n            refNode.parentNode.insertBefore(node, refNode);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we've inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    window.customElements.polyfillWrapFlushCallback !== undefined;\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=dom.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\nexport const directive = (f) => {\n    directives.set(f, true);\n    return f;\n};\nexport const isDirective = (o) => typeof o === 'function' && directives.has(o);\n//# sourceMappingURL=directive.js.map","/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n//# sourceMappingURL=part.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, processor, options) {\n        this._parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // When using the Custom Elements polyfill, clone the node, rather than\n        // importing it, to keep the fragment in the template's document. This\n        // leaves the fragment inert so custom elements won't upgrade and\n        // potentially modify their contents by creating a polyfilled ShadowRoot\n        // while we traverse the tree.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const parts = this.template.parts;\n        let partIndex = 0;\n        let nodeIndex = 0;\n        const _prepareInstance = (fragment) => {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n            let node = walker.nextNode();\n            // Loop through all the nodes and parts of a template\n            while (partIndex < parts.length && node !== null) {\n                const part = parts[partIndex];\n                // Consecutive Parts may have the same node index, in the case of\n                // multiple bound attributes on an element. So each iteration we either\n                // increment the nodeIndex, if we aren't on a node with a part, or the\n                // partIndex if we are. By not incrementing the nodeIndex when we find a\n                // part, we allow for the next part to be associated with the current\n                // node if neccessasry.\n                if (!isTemplatePartActive(part)) {\n                    this._parts.push(undefined);\n                    partIndex++;\n                }\n                else if (nodeIndex === part.index) {\n                    if (part.type === 'node') {\n                        const part = this.processor.handleTextExpression(this.options);\n                        part.insertAfterNode(node);\n                        this._parts.push(part);\n                    }\n                    else {\n                        this._parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n                    }\n                    partIndex++;\n                }\n                else {\n                    nodeIndex++;\n                    if (node.nodeName === 'TEMPLATE') {\n                        _prepareInstance(node.content);\n                    }\n                    node = walker.nextNode();\n                }\n            }\n        };\n        _prepareInstance(fragment);\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { reparentNodes } from './dom.js';\nimport { lastAttributeNameRegex, marker, nodeMarker, rewritesStyleAttribute } from './template.js';\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            const close = s.lastIndexOf('>');\n            // We're in a text position if the previous string closed its last tag, an\n            // attribute position if the string opened an unclosed tag, and unchanged\n            // if the string had no brackets at all:\n            //\n            // \"...>...\": text position. open === -1, close > -1\n            // \"...<...\": attribute position. open > -1\n            // \"...\": no change. open === -1, close === -1\n            isTextBinding =\n                (close > -1 || isTextBinding) && s.indexOf('<', close + 1) === -1;\n            if (!isTextBinding && rewritesStyleAttribute) {\n                html = html.replace(lastAttributeNameRegex, (match, p1, p2, p3) => {\n                    return (p2 === 'style') ? `${p1}style$${p3}` : match;\n                });\n            }\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = (value) => (value === null ||\n    !(typeof value === 'object' || typeof value === 'function'));\n/**\n * Sets attribute values for AttributeParts, so that the value is only set once\n * even if there are multiple parts for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (v != null &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n                else {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\nexport class AttributePart {\n    constructor(comitter) {\n        this.value = undefined;\n        this.committer = comitter;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\nexport class NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Inserts this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and\n     * its next sibling must be static, unchanging nodes such as those that appear\n     * in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part._insert(this.startNode = createMarker());\n        part._insert(this.endNode = createMarker());\n    }\n    /**\n     * Appends this part after `ref`\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref._insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        const value = this._pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this._commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this._commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this._commitNode(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._commitIterable(value);\n        }\n        else if (value.then !== undefined) {\n            this._commitPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this.value = value;\n    }\n    _commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.textContent = value;\n        }\n        else {\n            this._commitNode(document.createTextNode(typeof value === 'string' ? value : String(value)));\n        }\n        this.value = value;\n    }\n    _commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value && this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this._commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    _commitPromise(value) {\n        this.value = value;\n        value.then((v) => {\n            if (this.value === value) {\n                this.setValue(v);\n                this.commit();\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        const value = !!this._pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        this.value = value;\n        this._pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\ntry {\n    const options = {\n        get capture() {\n            eventOptionsSupported = true;\n            return false;\n        }\n    };\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n}\ncatch (_e) {\n}\nexport class EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        const newListener = this._pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this, this._options);\n        }\n        this._options = getOptions(newListener);\n        if (shouldAddListener) {\n            this.element.addEventListener(this.eventName, this, this._options);\n        }\n        this.value = newListener;\n        this._pendingValue = noChange;\n    }\n    handleEvent(event) {\n        const listener = (typeof this.value === 'function') ?\n            this.value :\n            (typeof this.value.handleEvent === 'function') ?\n                this.value.handleEvent :\n                () => null;\n        listener.call(this.eventContext || this.element, event);\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Template } from './template.js';\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nexport const templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { removeNodes } from './dom.js';\nimport { NodePart } from './parts.js';\nimport { templateFactory } from './template-factory.js';\nexport const parts = new WeakMap();\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render = (result, container, options) => {\n    let part = parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter } from './parts.js';\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const comitter = new PropertyCommitter(element, name.slice(1), strings);\n            return comitter.parts;\n        }\n        if (prefix === '@') {\n            return [new EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const comitter = new AttributeCommitter(element, name, strings);\n        return comitter.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new NodePart(options);\n    }\n}\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor.js';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport * from './lib/template-result.js';\nexport * from './lib/template.js';\nexport * from './lib/default-template-processor.js';\nexport * from './lib/template-instance.js';\nexport * from './lib/part.js';\nexport * from './lib/parts.js';\nexport * from './lib/dom.js';\nexport * from './lib/directive.js';\nexport * from './lib/render.js';\nexport * from './lib/template-factory.js';\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateResult } from './template-result.js';\nimport { Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(`Incompatible ShadyCSS version detected.` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.set(result.strings, template);\n    }\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn't support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll('style')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (renderedDOM, template, scopeName) => {\n    shadyRenderSet.add(scopeName);\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll('style');\n    // If there are no styles, there's no work to do.\n    if (styles.length === 0) {\n        return;\n    }\n    const condensedStyle = document.createElement('style');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < styles.length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the \"root\" template passed in as\n    // `template`.\n    insertNodeIntoTemplate(template, condensedStyle, template.element.content.firstChild);\n    // Note, it's important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);\n    if (window.ShadyCSS.nativeShadow) {\n        // When in native Shadow DOM, re-add styling to rendered content using\n        // the style ShadyCSS produced.\n        const style = template.element.content.querySelector('style');\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else {\n        // When not in native Shadow DOM, at this point ShadyCSS will have\n        // removed the style from the lit template and parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        template.element.content.insertBefore(condensedStyle, template.element.content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\nexport const render = (result, container, options) => {\n    const scopeName = options.scopeName;\n    const hasRendered = parts.has(container);\n    litRender(result, container, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When rendering a TemplateResult, scope the template with ShadyCSS\n    if (container instanceof ShadowRoot && compatibleShadyCSSVersion &&\n        result instanceof TemplateResult) {\n        // Scope the element template one time only for this scope.\n        if (!shadyRenderSet.has(scopeName)) {\n            const part = parts.get(container);\n            const instance = part.value;\n            prepareTemplateStyles(container, instance.template, scopeName);\n        }\n        // Update styling if this is the initial render to this container.\n        if (!hasRendered) {\n            window.ShadyCSS.styleElement(container.host);\n        }\n    }\n};\n//# sourceMappingURL=shady-render.js.map","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { render } from '../../lit-html/lib/shady-render.js';\nexport { html } from '../../lit-html/lib/shady-render.js';\n\n// Key to store the HTML tag in a custom element class\nconst TAG = Symbol('tag');\n\n// Key to store render status in a custom element instance\nconst NEEDSRENDER = Symbol('needsRender');\n\n// Transforms a camelCased string into a kebab-cased string\nconst camelToKebab = camel => camel.replace(/([a-z](?=[A-Z]))|([A-Z](?=[A-Z][a-z]))/g, '$1$2-').toLowerCase();\n\n// Creates an ID cache in the `$` property of a custom element instance\nconst createIdCache = element => {\n  element.$ = {};\n  element.renderRoot.querySelectorAll('[id]').forEach(node => {\n    element.$[node.id] = node;\n  });\n};\n\n/**\n * A lightweight base class for custom elements\n *\n * Features:\n *\n *  - Determines an appropriate HTML tagname based on an element's class name\n *  - Efficient rendering engine using lit-html (https://github.com/Polymer/lit-html)\n *  - Creates a cache for descendant nodes with an `id` in the `$` property\n */\nexport class GluonElement extends HTMLElement {\n  constructor() {\n    super();\n    this.renderRoot = this.createRenderRoot();\n\n    // This ensures that any properties that are set prior to upgrading this element\n    // have their instance setters called\n    Object.getOwnPropertyNames(this).forEach(property => {\n      const propertyValue = this[property];\n      delete this[property];\n      this[property] = propertyValue;\n    });\n  }\n\n  /**\n   * Returns an open shadowRoot as the default rendering root\n   *\n   * Override this method to provide an alternative rendering root\n   * For example, return `this` to render the template as childNodes\n   */\n  createRenderRoot() {\n    return this.attachShadow({ mode: 'open' });\n  }\n\n  /**\n   * Returns the HTML tagname for elements of this class\n   *\n   * It defaults to the kebab-cased version of the class name. To override,\n   * defined a `static get is()` property on your custom element class, and return\n   * whatever string you want to use for the HTML tagname\n   */\n  static get is() {\n    return (this.hasOwnProperty(TAG) && this[TAG]) || (this[TAG] = camelToKebab(this.name));\n  }\n\n  /**\n   * Called when an element is connected to the DOM\n   *\n   * When an element has a `template`, attach a shadowRoot to the element,\n   * and render the template. Once the template is rendered, creates an ID cache\n   * in the `$` property\n   *\n   * When adding a `connectedCallback` to your custom element, you should call\n   * `super.connectedCallback()` before doing anything other than actions\n   * that alter the result of the template rendering.\n   */\n  connectedCallback() {\n    if ('template' in this) {\n      this.render({ sync: true });\n      createIdCache(this);\n    }\n  }\n\n  /**\n   * Renders the template for this element into the shadowRoot\n   *\n   * @param { sync }: perform a synchronous (blocking) render. The default render\n   *     is asynchronous, and multiple calls to `render()` are batched by default\n   *\n   * @returns a Promise that resolves once template has been rendered\n   */\n  async render({ sync = false } = {}) {\n    this[NEEDSRENDER] = true;\n    if (!sync) {\n      await 0;\n    }\n    if (this[NEEDSRENDER]) {\n      this[NEEDSRENDER] = false;\n      render(this.template, this.renderRoot, { scopeName: this.constructor.is, eventContext: this });\n    }\n  }\n}\n"],"names":["marker","String","Math","random","slice","nodeMarker","markerRegex","RegExp","rewritesStyleAttribute","el","document","createElement","setAttribute","getAttribute","Template","result","element","parts","index","partIndex","nodesToRemove","_prepareTemplate","template","content","walker","createTreeWalker","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","count","i","length","value","indexOf","stringForPart","strings","name","lastAttributeNameRegex","exec","attributeLookupName","test","toLowerCase","attributeValue","split","push","type","removeAttribute","tagName","nodeValue","parent","parentNode","lastIndex","insertBefore","createMarker","createTextNode","previousSibling","Node","TEXT_NODE","nextSibling","n","removeChild","isTemplatePartActive","part","createComment","walkerNodeFilter","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","removeNodesFromTemplate","nextActiveIndexInTemplateParts","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","has","undefined","forEach","countNodes","DOCUMENT_FRAGMENT_NODE","startIndex","insertNodeIntoTemplate","refNode","appendChild","insertCount","walkerIndex","walkerNode","isCEPolyfill","window","customElements","polyfillWrapFlushCallback","reparentNodes","container","start","end","before","removeNodes","startNode","endNode","directives","WeakMap","isDirective","o","noChange","TemplateInstance","processor","options","_parts","values","setValue","commit","fragment","cloneNode","importNode","_prepareInstance","handleTextExpression","insertAfterNode","handleAttributeExpressions","nodeName","adoptNode","upgrade","TemplateResult","l","html","isTextBinding","s","close","lastIndexOf","replace","match","p1","p2","p3","innerHTML","getHTML","SVGTemplateResult","svgElement","firstChild","isPrimitive","AttributeCommitter","dirty","_createPart","AttributePart","text","v","Array","isArray","Symbol","iterator","t","_getValue","comitter","committer","directive","NodePart","_pendingValue","ref","_insert","_commitText","_commitTemplateResult","_commitNode","_commitIterable","then","_commitPromise","clear","textContent","templateFactory","update","instance","_clone","itemParts","itemPart","item","appendIntoPart","insertAfterPart","BooleanAttributePart","Error","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","_options","getOptions","event","listener","handleEvent","call","templateCache","templateCaches","get","Map","set","getTemplateElement","render","Object","assign","appendInto","DefaultTemplateProcessor","prefix","defaultTemplateProcessor","getTemplateCacheKey","scopeName","compatibleShadyCSSVersion","ShadyCSS","prepareTemplateDom","warn","shadyTemplateFactory","cacheKey","TEMPLATE_TYPES","removeStylesFromLitTemplates","templates","styles","Set","from","querySelectorAll","add","shadyRenderSet","prepareTemplateStyles","renderedDOM","condensedStyle","style","nativeShadow","querySelector","removes","hasRendered","ShadowRoot","styleElement","host","TAG","NEEDSRENDER","camelToKebab","camel","createIdCache","$","renderRoot","id","GluonElement","createRenderRoot","getOwnPropertyNames","propertyValue","property","attachShadow","mode","sync","constructor","is","hasOwnProperty","HTMLElement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,AAAO,IAAMA,oBAAkBC,OAAOC,KAAKC,MAAL,EAAP,EAAsBC,KAAtB,CAA4B,CAA5B,CAAlB,OAAN;;;;;AAKP,AAAO,IAAMC,sBAAoBL,MAApB,QAAN;AACP,AAAO,IAAMM,cAAc,IAAIC,MAAJ,CAAcP,MAAd,SAAwBK,UAAxB,CAApB;AACP,AAAO,IAAMG,yBAA0B,YAAM;QACnCC,KAAKC,SAASC,aAAT,CAAuB,KAAvB,CAAX;OACGC,YAAH,CAAgB,OAAhB,EAAyB,eAAzB;WACOH,GAAGI,YAAH,CAAgB,OAAhB,MAA6B,eAApC;CAHkC,EAA/B;;;;AAQP,IAAaC,QAAb,GACI,kBAAYC,MAAZ,EAAoBC,OAApB,EAA6B;;;;;SACpBC,KAAL,GAAa,EAAb;SACKD,OAAL,GAAeA,OAAf;QACIE,QAAQ,CAAC,CAAb;QACIC,YAAY,CAAhB;QACMC,gBAAgB,EAAtB;QACMC,mBAAmB,SAAnBA,gBAAmB,CAACC,QAAD,EAAc;YAC7BC,UAAUD,SAASC,OAAzB;;;YAGMC,SAASd,SAASe,gBAAT,CAA0BF,OAA1B,EAAmC,GAAnC;qFACiB,IADjB,EACuB,KADvB,CAAf;;;YAIIG,qBAAJ;;YAEIC,oBAAJ;eACOH,OAAOI,QAAP,EAAP,EAA0B;;2BAEPD,WAAf;gBACME,OAAOF,cAAcH,OAAOG,WAAlC;gBACIE,KAAKC,QAAL,KAAkB,CAAtB,0BAAiD;wBACzCD,KAAKE,aAAL,EAAJ,EAA0B;4BAChBC,aAAaH,KAAKG,UAAxB;;;;;;4BAMIC,QAAQ,CAAZ;6BACK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,WAAWG,MAA/B,EAAuCD,GAAvC,EAA4C;gCACpCF,WAAWE,CAAX,EAAcE,KAAd,CAAoBC,OAApB,CAA4BrC,MAA5B,KAAuC,CAA3C,EAA8C;;;;+BAI3CiC,UAAU,CAAjB,EAAoB;;;gCAGVK,gBAAgBvB,OAAOwB,OAAP,CAAepB,SAAf,CAAtB;;gCAEMqB,OAAOC,uBAAuBC,IAAvB,CAA4BJ,aAA5B,EAA2C,CAA3C,CAAb;;;;;;;;;;gCAUMK,sBAAuBnC,0BAA0BgC,SAAS,OAApC,GACxB,QADwB,GAExB,eAAeI,IAAf,CAAoBJ,IAApB,IAA4BA,IAA5B,GAAmCA,KAAKK,WAAL,EAFvC;gCAGMC,iBAAiBjB,KAAKhB,YAAL,CAAkB8B,mBAAlB,CAAvB;gCACMJ,UAAUO,eAAeC,KAAf,CAAqBzC,WAArB,CAAhB;kCACKW,KAAL,CAAW+B,IAAX,CAAgB,EAAEC,MAAM,WAAR,EAAqB/B,YAArB,EAA4BsB,UAA5B,EAAkCD,gBAAlC,EAAhB;iCACKW,eAAL,CAAqBP,mBAArB;yCACaJ,QAAQJ,MAAR,GAAiB,CAA9B;;;wBAGJN,KAAKsB,OAAL,KAAiB,UAArB,EAAiC;yCACZtB,IAAjB;;iBAxCR,MA2CK,IAAIA,KAAKC,QAAL,KAAkB,CAAtB,uBAA8C;wBACzCsB,YAAYvB,KAAKuB,SAAvB;wBACIA,UAAUf,OAAV,CAAkBrC,MAAlB,IAA4B,CAAhC,EAAmC;;;wBAG7BqD,SAASxB,KAAKyB,UAApB;wBACMf,WAAUa,UAAUL,KAAV,CAAgBzC,WAAhB,CAAhB;wBACMiD,YAAYhB,SAAQJ,MAAR,GAAiB,CAAnC;;iCAEaoB,SAAb;;;yBAGK,IAAIrB,KAAI,CAAb,EAAgBA,KAAIqB,SAApB,EAA+BrB,IAA/B,EAAoC;+BACzBsB,YAAP,CAAqBjB,SAAQL,EAAR,MAAe,EAAhB,GAAsBuB,cAAtB,GAChB/C,SAASgD,cAAT,CAAwBnB,SAAQL,EAAR,CAAxB,CADJ,EACyCL,IADzC;8BAEKZ,KAAL,CAAW+B,IAAX,CAAgB,EAAEC,MAAM,MAAR,EAAgB/B,OAAOA,OAAvB,EAAhB;;2BAEGsC,YAAP,CAAoBjB,SAAQgB,SAAR,MAAuB,EAAvB,GAChBE,cADgB,GAEhB/C,SAASgD,cAAT,CAAwBnB,SAAQgB,SAAR,CAAxB,CAFJ,EAEiD1B,IAFjD;kCAGcmB,IAAd,CAAmBnB,IAAnB;iBApBC,MAsBA,IAAIA,KAAKC,QAAL,KAAkB,CAAtB,0BAAiD;wBAC9CD,KAAKuB,SAAL,KAAmBpD,MAAvB,EAA+B;4BACrBqD,UAASxB,KAAKyB,UAApB;;;;;;;;;;;;4BAYMK,kBAAkB9B,KAAK8B,eAA7B;4BACIA,oBAAoB,IAApB,IAA4BA,oBAAoBjC,YAAhD,IACAiC,gBAAgB7B,QAAhB,KAA6B8B,KAAKC,SADtC,EACiD;oCACtCL,YAAP,CAAoBC,cAApB,EAAoC5B,IAApC;yBAFJ,MAIK;;;8BAGAZ,KAAL,CAAW+B,IAAX,CAAgB,EAAEC,MAAM,MAAR,EAAgB/B,OAAOA,OAAvB,EAAhB;sCACc8B,IAAd,CAAmBnB,IAAnB;;;;4BAIIA,KAAKiC,WAAL,KAAqB,IAAzB,EAA+B;oCACpBN,YAAP,CAAoBC,cAApB,EAAoC5B,IAApC;yBADJ,MAGK;;;sCAGSH,YAAd;;qBAhCJ,MAmCK;4BACGQ,MAAI,CAAC,CAAT;+BACO,CAACA,MAAIL,KAAKuB,SAAL,CAAef,OAAf,CAAuBrC,MAAvB,EAA+BkC,MAAI,CAAnC,CAAL,MAAgD,CAAC,CAAxD,EAA2D;;;;;kCAKlDjB,KAAL,CAAW+B,IAAX,CAAgB,EAAEC,MAAM,MAAR,EAAgB/B,OAAO,CAAC,CAAxB,EAAhB;;;;;KA3HpB;qBAiIiBF,OAAjB;;;;;;;6BAEgBI,aAAhB,8HAA+B;gBAApB2C,CAAoB;;cACzBT,UAAF,CAAaU,WAAb,CAAyBD,CAAzB;;;;;;;;;;;;;;;;CA3IZ;AA+IA,AAAO,IAAME,uBAAuB,SAAvBA,oBAAuB,CAACC,IAAD;WAAUA,KAAKhD,KAAL,KAAe,CAAC,CAA1B;CAA7B;;;AAGP,AAAO,IAAMuC,eAAe,SAAfA,YAAe;WAAM/C,SAASyD,aAAT,CAAuB,EAAvB,CAAN;CAArB;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BP,AAAO,IAAM1B,yBAAyB,4JAA/B;;AC5MP;;;;;;;;;;;;;AAaA,AACA,IAAM2B,mBAAmBC,WAAWC,YAAX,GAA0BD,WAAWE,YAArC,GAAoDF,WAAWG,SAAxF;;;;;;;;;;;;;;;;;AAiBA,AAAO,SAASC,uBAAT,CAAiCnD,QAAjC,EAA2CF,aAA3C,EAA0D;QAC1CG,OAD0C,GACrBD,QADqB,CACrDN,OADqD,CAC1CO,OAD0C;QAC/BN,KAD+B,GACrBK,QADqB,CAC/BL,KAD+B;;QAEvDO,SAASd,SAASe,gBAAT,CAA0BF,OAA1B,EAAmC6C,gBAAnC,EAAqD,IAArD,EAA2D,KAA3D,CAAf;QACIjD,YAAYuD,+BAA+BzD,KAA/B,CAAhB;QACIiD,OAAOjD,MAAME,SAAN,CAAX;QACIwD,YAAY,CAAC,CAAjB;QACIC,cAAc,CAAlB;QACMC,0BAA0B,EAAhC;QACIC,sBAAsB,IAA1B;WACOtD,OAAOI,QAAP,EAAP,EAA0B;;YAEhBC,OAAOL,OAAOG,WAApB;;YAEIE,KAAK8B,eAAL,KAAyBmB,mBAA7B,EAAkD;kCACxB,IAAtB;;;YAGA1D,cAAc2D,GAAd,CAAkBlD,IAAlB,CAAJ,EAA6B;oCACDmB,IAAxB,CAA6BnB,IAA7B;;gBAEIiD,wBAAwB,IAA5B,EAAkC;sCACRjD,IAAtB;;;;YAIJiD,wBAAwB,IAA5B,EAAkC;;;eAG3BZ,SAASc,SAAT,IAAsBd,KAAKhD,KAAL,KAAeyD,SAA5C,EAAuD;;;iBAG9CzD,KAAL,GAAa4D,wBAAwB,IAAxB,GAA+B,CAAC,CAAhC,GAAoCZ,KAAKhD,KAAL,GAAa0D,WAA9D;;wBAEYF,+BAA+BzD,KAA/B,EAAsCE,SAAtC,CAAZ;mBACOF,MAAME,SAAN,CAAP;;;4BAGgB8D,OAAxB,CAAgC,UAAClB,CAAD;eAAOA,EAAET,UAAF,CAAaU,WAAb,CAAyBD,CAAzB,CAAP;KAAhC;;AAEJ,IAAMmB,aAAa,SAAbA,UAAa,CAACrD,IAAD,EAAU;QACrBI,QAASJ,KAAKC,QAAL,KAAkB8B,KAAKuB,sBAAxB,GAAkD,CAAlD,GAAsD,CAAlE;QACM3D,SAASd,SAASe,gBAAT,CAA0BI,IAA1B,EAAgCuC,gBAAhC,EAAkD,IAAlD,EAAwD,KAAxD,CAAf;WACO5C,OAAOI,QAAP,EAAP,EAA0B;;;WAGnBK,KAAP;CANJ;AAQA,IAAMyC,iCAAiC,SAAjCA,8BAAiC,CAACzD,KAAD,EAA4B;QAApBmE,UAAoB,uEAAP,CAAC,CAAM;;SAC1D,IAAIlD,IAAIkD,aAAa,CAA1B,EAA6BlD,IAAIjB,MAAMkB,MAAvC,EAA+CD,GAA/C,EAAoD;YAC1CgC,OAAOjD,MAAMiB,CAAN,CAAb;YACI+B,qBAAqBC,IAArB,CAAJ,EAAgC;mBACrBhC,CAAP;;;WAGD,CAAC,CAAR;CAPJ;;;;;;AAcA,AAAO,SAASmD,sBAAT,CAAgC/D,QAAhC,EAA0CO,IAA1C,EAAgE;QAAhByD,OAAgB,uEAAN,IAAM;QAChD/D,OADgD,GAC3BD,QAD2B,CAC3DN,OAD2D,CAChDO,OADgD;QACrCN,KADqC,GAC3BK,QAD2B,CACrCL,KADqC;;;;QAI/DqE,YAAY,IAAZ,IAAoBA,YAAYN,SAApC,EAA+C;gBACnCO,WAAR,CAAoB1D,IAApB;;;QAGEL,SAASd,SAASe,gBAAT,CAA0BF,OAA1B,EAAmC6C,gBAAnC,EAAqD,IAArD,EAA2D,KAA3D,CAAf;QACIjD,YAAYuD,+BAA+BzD,KAA/B,CAAhB;QACIuE,cAAc,CAAlB;QACIC,cAAc,CAAC,CAAnB;WACOjE,OAAOI,QAAP,EAAP,EAA0B;;YAEhB8D,aAAalE,OAAOG,WAA1B;YACI+D,eAAeJ,OAAnB,EAA4B;0BACVJ,WAAWrD,IAAX,CAAd;oBACQyB,UAAR,CAAmBE,YAAnB,CAAgC3B,IAAhC,EAAsCyD,OAAtC;;eAEGnE,cAAc,CAAC,CAAf,IAAoBF,MAAME,SAAN,EAAiBD,KAAjB,KAA2BuE,WAAtD,EAAmE;;gBAE3DD,cAAc,CAAlB,EAAqB;uBACVrE,cAAc,CAAC,CAAtB,EAAyB;0BACfA,SAAN,EAAiBD,KAAjB,IAA0BsE,WAA1B;gCACYd,+BAA+BzD,KAA/B,EAAsCE,SAAtC,CAAZ;;;;wBAIIuD,+BAA+BzD,KAA/B,EAAsCE,SAAtC,CAAZ;;;;;ACxHZ;;;;;;;;;;;;;AAaA,AAAO,IAAMwE,eAAeC,OAAOC,cAAP,KAA0Bb,SAA1B,IACxBY,OAAOC,cAAP,CAAsBC,yBAAtB,KAAoDd,SADjD;;;;;;;AAQP,AAAO,IAAMe,gBAAgB,SAAhBA,aAAgB,CAACC,SAAD,EAAYC,KAAZ,EAAiD;QAA9BC,GAA8B,uEAAxB,IAAwB;QAAlBC,MAAkB,uEAAT,IAAS;;QACtEtE,OAAOoE,KAAX;WACOpE,SAASqE,GAAhB,EAAqB;YACXnC,IAAIlC,KAAKiC,WAAf;kBACUN,YAAV,CAAuB3B,IAAvB,EAA6BsE,MAA7B;eACOpC,CAAP;;CALD;;;;;AAYP,AAAO,IAAMqC,cAAc,SAAdA,WAAc,CAACJ,SAAD,EAAYK,SAAZ,EAA0C;QAAnBC,OAAmB,uEAAT,IAAS;;QAC7DzE,OAAOwE,SAAX;WACOxE,SAASyE,OAAhB,EAAyB;YACfvC,IAAIlC,KAAKiC,WAAf;kBACUE,WAAV,CAAsBnC,IAAtB;eACOkC,CAAP;;CALD;;ACjCP;;;;;;;;;;;;;AAaA,IAAMwC,aAAa,IAAIC,OAAJ,EAAnB;AACA;AAIA,AAAO,IAAMC,cAAc,SAAdA,WAAc,CAACC,CAAD;SAAO,OAAOA,CAAP,KAAa,UAAb,IAA2BH,WAAWxB,GAAX,CAAe2B,CAAf,CAAlC;CAApB;;AClBP;;;;AAIA,AAAO,IAAMC,WAAW,EAAjB;;ACJP;;;;;;;;;;;;;AAaA,AAEA;;;;AAIA,IAAaC,gBAAb;8BACgBtF,QAAZ,EAAsBuF,SAAtB,EAAiCC,OAAjC,EAA0C;;;aACjCC,MAAL,GAAc,EAAd;aACKzF,QAAL,GAAgBA,QAAhB;aACKuF,SAAL,GAAiBA,SAAjB;aACKC,OAAL,GAAeA,OAAf;;;;;+BAEGE,MAPX,EAOmB;gBACP9E,IAAI,CAAR;;;;;;qCACmB,KAAK6E,MAAxB,8HAAgC;wBAArB7C,IAAqB;;wBACxBA,SAASc,SAAb,EAAwB;6BACfiC,QAAL,CAAcD,OAAO9E,CAAP,CAAd;;;;;;;;;;;;;;;;;;;;;;;;sCAIW,KAAK6E,MAAxB,mIAAgC;wBAArB7C,KAAqB;;wBACxBA,UAASc,SAAb,EAAwB;8BACfkC,MAAL;;;;;;;;;;;;;;;;;;;;iCAIH;;;;;;;;gBAMCC,WAAWxB,eACb,KAAKrE,QAAL,CAAcN,OAAd,CAAsBO,OAAtB,CAA8B6F,SAA9B,CAAwC,IAAxC,CADa,GAEb1G,SAAS2G,UAAT,CAAoB,KAAK/F,QAAL,CAAcN,OAAd,CAAsBO,OAA1C,EAAmD,IAAnD,CAFJ;gBAGMN,QAAQ,KAAKK,QAAL,CAAcL,KAA5B;gBACIE,YAAY,CAAhB;gBACIwD,YAAY,CAAhB;gBACM2C,mBAAmB,SAAnBA,gBAAmB,CAACH,QAAD,EAAc;;;oBAG7B3F,SAASd,SAASe,gBAAT,CAA0B0F,QAA1B,EAAoC,GAApC,+CAAsF,IAAtF,EAA4F,KAA5F,CAAf;oBACItF,OAAOL,OAAOI,QAAP,EAAX;;uBAEOT,YAAYF,MAAMkB,MAAlB,IAA4BN,SAAS,IAA5C,EAAkD;wBACxCqC,OAAOjD,MAAME,SAAN,CAAb;;;;;;;wBAOI,CAAC8C,qBAAqBC,IAArB,CAAL,EAAiC;8BACxB6C,MAAL,CAAY/D,IAAZ,CAAiBgC,SAAjB;;qBADJ,MAIK,IAAIL,cAAcT,KAAKhD,KAAvB,EAA8B;4BAC3BgD,KAAKjB,IAAL,KAAc,MAAlB,EAA0B;gCAChBiB,SAAO,MAAK2C,SAAL,CAAeU,oBAAf,CAAoC,MAAKT,OAAzC,CAAb;mCACKU,eAAL,CAAqB3F,IAArB;kCACKkF,MAAL,CAAY/D,IAAZ,CAAiBkB,MAAjB;yBAHJ,MAKK;;;4CACI6C,MAAL,EAAY/D,IAAZ,iCAAoB,MAAK6D,SAAL,CAAeY,0BAAf,CAA0C5F,IAA1C,EAAgDqC,KAAK1B,IAArD,EAA2D0B,KAAK3B,OAAhE,EAAyE,MAAKuE,OAA9E,CAApB;;;qBAPH,MAWA;;4BAEGjF,KAAK6F,QAAL,KAAkB,UAAtB,EAAkC;6CACb7F,KAAKN,OAAtB;;+BAEGC,OAAOI,QAAP,EAAP;;;aAlCZ;6BAsCiBuF,QAAjB;gBACIxB,YAAJ,EAAkB;yBACLgC,SAAT,CAAmBR,QAAnB;+BACeS,OAAf,CAAuBT,QAAvB;;mBAEGA,QAAP;;;;;;AC/FR;;;;;;;;;;;;;AAaA,AAEA;;;;AAIA,IAAaU,cAAb;4BACgBtF,OAAZ,EAAqByE,MAArB,EAA6B/D,IAA7B,EAAmC4D,SAAnC,EAA8C;;;aACrCtE,OAAL,GAAeA,OAAf;aACKyE,MAAL,GAAcA,MAAd;aACK/D,IAAL,GAAYA,IAAZ;aACK4D,SAAL,GAAiBA,SAAjB;;;;;;;;kCAKM;gBACAiB,IAAI,KAAKvF,OAAL,CAAaJ,MAAb,GAAsB,CAAhC;gBACI4F,OAAO,EAAX;gBACIC,gBAAgB,IAApB;iBACK,IAAI9F,IAAI,CAAb,EAAgBA,IAAI4F,CAApB,EAAuB5F,GAAvB,EAA4B;oBAClB+F,IAAI,KAAK1F,OAAL,CAAaL,CAAb,CAAV;wBACQ+F,CAAR;oBACMC,QAAQD,EAAEE,WAAF,CAAc,GAAd,CAAd;;;;;;;;gCASI,CAACD,QAAQ,CAAC,CAAT,IAAcF,aAAf,KAAiCC,EAAE5F,OAAF,CAAU,GAAV,EAAe6F,QAAQ,CAAvB,MAA8B,CAAC,CADpE;oBAEI,CAACF,aAAD,IAAkBxH,sBAAtB,EAA8C;2BACnCuH,KAAKK,OAAL,CAAa3F,sBAAb,EAAqC,UAAC4F,KAAD,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAuB;+BACvDD,OAAO,OAAR,GAAsBD,EAAtB,cAAiCE,EAAjC,GAAwCH,KAA/C;qBADG,CAAP;;wBAIIL,gBAAgB3H,UAAhB,GAA6BL,MAArC;;oBAEI,KAAKuC,OAAL,CAAauF,CAAb,CAAR;mBACOC,IAAP;;;;6CAEiB;gBACXzG,WAAWZ,SAASC,aAAT,CAAuB,UAAvB,CAAjB;qBACS8H,SAAT,GAAqB,KAAKC,OAAL,EAArB;mBACOpH,QAAP;;;;;;;;;;;;AAUR,IAAaqH,iBAAb;;;;;;;;;;kCACc;;;;;6CAGW;gBACXrH,kJAAN;gBACMC,UAAUD,SAASC,OAAzB;gBACMqH,aAAarH,QAAQsH,UAA3B;oBACQ7E,WAAR,CAAoB4E,UAApB;0BACcrH,OAAd,EAAuBqH,WAAWC,UAAlC;mBACOvH,QAAP;;;;EAV+BuG,cAAvC;;ACrEA;;;;;;;;;;;;;AAaA,AAMO,IAAMiB,cAAc,SAAdA,WAAc,CAAC1G,KAAD;WAAYA,UAAU,IAAV,IACnC,EAAE,QAAOA,KAAP,yCAAOA,KAAP,OAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,UAAhD,CADuB;CAApB;;;;;AAMP,IAAa2G,kBAAb;gCACgB/H,OAAZ,EAAqBwB,IAArB,EAA2BD,OAA3B,EAAoC;;;aAC3ByG,KAAL,GAAa,IAAb;aACKhI,OAAL,GAAeA,OAAf;aACKwB,IAAL,GAAYA,IAAZ;aACKD,OAAL,GAAeA,OAAf;aACKtB,KAAL,GAAa,EAAb;aACK,IAAIiB,IAAI,CAAb,EAAgBA,IAAIK,QAAQJ,MAAR,GAAiB,CAArC,EAAwCD,GAAxC,EAA6C;iBACpCjB,KAAL,CAAWiB,CAAX,IAAgB,KAAK+G,WAAL,EAAhB;;;;;;;;;sCAMM;mBACH,IAAIC,aAAJ,CAAkB,IAAlB,CAAP;;;;oCAEQ;gBACF3G,UAAU,KAAKA,OAArB;gBACMuF,IAAIvF,QAAQJ,MAAR,GAAiB,CAA3B;gBACIgH,OAAO,EAAX;iBACK,IAAIjH,IAAI,CAAb,EAAgBA,IAAI4F,CAApB,EAAuB5F,GAAvB,EAA4B;wBAChBK,QAAQL,CAAR,CAAR;oBACMgC,OAAO,KAAKjD,KAAL,CAAWiB,CAAX,CAAb;oBACIgC,SAASc,SAAb,EAAwB;wBACdoE,IAAIlF,KAAK9B,KAAf;wBACIgH,KAAK,IAAL,KACCC,MAAMC,OAAN,CAAcF,CAAd,KAAoB,OAAOA,CAAP,KAAa,QAAb,IAAyBA,EAAEG,OAAOC,QAAT,CAD9C,CAAJ,EACuE;;;;;;iDACnDJ,CAAhB,8HAAmB;oCAARK,CAAQ;;wCACP,OAAOA,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4BxJ,OAAOwJ,CAAP,CAApC;;;;;;;;;;;;;;;;qBAHR,MAMK;gCACO,OAAOL,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4BnJ,OAAOmJ,CAAP,CAApC;;;;oBAIJ7G,QAAQuF,CAAR,CAAR;mBACOqB,IAAP;;;;iCAEK;gBACD,KAAKH,KAAT,EAAgB;qBACPA,KAAL,GAAa,KAAb;qBACKhI,OAAL,CAAaJ,YAAb,CAA0B,KAAK4B,IAA/B,EAAqC,KAAKkH,SAAL,EAArC;;;;;;AAIZ,IAAaR,aAAb;2BACgBS,QAAZ,EAAsB;;;aACbvH,KAAL,GAAa4C,SAAb;aACK4E,SAAL,GAAiBD,QAAjB;;;;;iCAEKvH,KALb,EAKoB;gBACRA,UAAUuE,QAAV,KAAuB,CAACmC,YAAY1G,KAAZ,CAAD,IAAuBA,UAAU,KAAKA,KAA7D,CAAJ,EAAyE;qBAChEA,KAAL,GAAaA,KAAb;;;;oBAII,CAACqE,YAAYrE,KAAZ,CAAL,EAAyB;yBAChBwH,SAAL,CAAeZ,KAAf,GAAuB,IAAvB;;;;;;iCAIH;mBACEvC,YAAY,KAAKrE,KAAjB,CAAP,EAAgC;oBACtByH,eAAY,KAAKzH,KAAvB;qBACKA,KAAL,GAAauE,QAAb;6BACU,IAAV;;gBAEA,KAAKvE,KAAL,KAAeuE,QAAnB,EAA6B;;;iBAGxBiD,SAAL,CAAe1C,MAAf;;;;;AAGR,IAAa4C,QAAb;sBACgBhD,OAAZ,EAAqB;;;aACZ1E,KAAL,GAAa4C,SAAb;aACK+E,aAAL,GAAqB/E,SAArB;aACK8B,OAAL,GAAeA,OAAf;;;;;;;;;;mCAOOd,SAXf,EAW0B;iBACbK,SAAL,GAAiBL,UAAUT,WAAV,CAAsB9B,cAAtB,CAAjB;iBACK6C,OAAL,GAAeN,UAAUT,WAAV,CAAsB9B,cAAtB,CAAf;;;;;;;;;;;;wCASYuG,GAtBpB,EAsByB;iBACZ3D,SAAL,GAAiB2D,GAAjB;iBACK1D,OAAL,GAAe0D,IAAIlG,WAAnB;;;;;;;;;;uCAOWI,IA/BnB,EA+ByB;iBACZ+F,OAAL,CAAa,KAAK5D,SAAL,GAAiB5C,cAA9B;iBACKwG,OAAL,CAAa,KAAK3D,OAAL,GAAe7C,cAA5B;;;;;;;;;;wCAOYuG,GAxCpB,EAwCyB;gBACbC,OAAJ,CAAY,KAAK5D,SAAL,GAAiB5C,cAA7B;iBACK6C,OAAL,GAAe0D,IAAI1D,OAAnB;gBACIA,OAAJ,GAAc,KAAKD,SAAnB;;;;iCAEKjE,KA7Cb,EA6CoB;iBACP2H,aAAL,GAAqB3H,KAArB;;;;iCAEK;mBACEqE,YAAY,KAAKsD,aAAjB,CAAP,EAAwC;oBAC9BF,eAAY,KAAKE,aAAvB;qBACKA,aAAL,GAAqBpD,QAArB;6BACU,IAAV;;gBAEEvE,QAAQ,KAAK2H,aAAnB;gBACI3H,UAAUuE,QAAd,EAAwB;;;gBAGpBmC,YAAY1G,KAAZ,CAAJ,EAAwB;oBAChBA,UAAU,KAAKA,KAAnB,EAA0B;yBACjB8H,WAAL,CAAiB9H,KAAjB;;aAFR,MAKK,IAAIA,iBAAiByF,cAArB,EAAqC;qBACjCsC,qBAAL,CAA2B/H,KAA3B;aADC,MAGA,IAAIA,iBAAiBwB,IAArB,EAA2B;qBACvBwG,WAAL,CAAiBhI,KAAjB;aADC,MAGA,IAAIiH,MAAMC,OAAN,CAAclH,KAAd,KAAwBA,MAAMmH,OAAOC,QAAb,CAA5B,EAAoD;qBAChDa,eAAL,CAAqBjI,KAArB;aADC,MAGA,IAAIA,MAAMkI,IAAN,KAAetF,SAAnB,EAA8B;qBAC1BuF,cAAL,CAAoBnI,KAApB;aADC,MAGA;;qBAEI8H,WAAL,CAAiB9H,KAAjB;;;;;gCAGAP,IAhFZ,EAgFkB;iBACLyE,OAAL,CAAahD,UAAb,CAAwBE,YAAxB,CAAqC3B,IAArC,EAA2C,KAAKyE,OAAhD;;;;oCAEQlE,KAnFhB,EAmFuB;gBACX,KAAKA,KAAL,KAAeA,KAAnB,EAA0B;;;iBAGrBoI,KAAL;iBACKP,OAAL,CAAa7H,KAAb;iBACKA,KAAL,GAAaA,KAAb;;;;oCAEQA,KA3FhB,EA2FuB;gBACTP,OAAO,KAAKwE,SAAL,CAAevC,WAA5B;oBACQ1B,SAAS,IAAT,GAAgB,EAAhB,GAAqBA,KAA7B;gBACIP,SAAS,KAAKyE,OAAL,CAAa3C,eAAtB,IACA9B,KAAKC,QAAL,KAAkB8B,KAAKC,SAD3B,EACsC;;;;qBAI7B4G,WAAL,GAAmBrI,KAAnB;aALJ,MAOK;qBACIgI,WAAL,CAAiB1J,SAASgD,cAAT,CAAwB,OAAOtB,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCnC,OAAOmC,KAAP,CAA5D,CAAjB;;iBAECA,KAAL,GAAaA,KAAb;;;;8CAEkBA,KA1G1B,EA0GiC;gBACnBd,WAAW,KAAKwF,OAAL,CAAa4D,eAAb,CAA6BtI,KAA7B,CAAjB;gBACI,KAAKA,KAAL,IAAc,KAAKA,KAAL,CAAWd,QAAX,KAAwBA,QAA1C,EAAoD;qBAC3Cc,KAAL,CAAWuI,MAAX,CAAkBvI,MAAM4E,MAAxB;aADJ,MAGK;;;;;oBAKK4D,WAAW,IAAIhE,gBAAJ,CAAqBtF,QAArB,EAA+Bc,MAAMyE,SAArC,EAAgD,KAAKC,OAArD,CAAjB;oBACMK,WAAWyD,SAASC,MAAT,EAAjB;yBACSF,MAAT,CAAgBvI,MAAM4E,MAAtB;qBACKoD,WAAL,CAAiBjD,QAAjB;qBACK/E,KAAL,GAAawI,QAAb;;;;;wCAGQxI,KA3HpB,EA2H2B;;;;;;;;;;gBAUf,CAACiH,MAAMC,OAAN,CAAc,KAAKlH,KAAnB,CAAL,EAAgC;qBACvBA,KAAL,GAAa,EAAb;qBACKoI,KAAL;;;;gBAIEM,YAAY,KAAK1I,KAAvB;gBACIjB,YAAY,CAAhB;gBACI4J,iBAAJ;;;;;;sCACmB3I,KAAnB,mIAA0B;wBAAf4I,IAAe;;;+BAEXF,UAAU3J,SAAV,CAAX;;wBAEI4J,aAAa/F,SAAjB,EAA4B;mCACb,IAAI8E,QAAJ,CAAa,KAAKhD,OAAlB,CAAX;kCACU9D,IAAV,CAAe+H,QAAf;4BACI5J,cAAc,CAAlB,EAAqB;qCACR8J,cAAT,CAAwB,IAAxB;yBADJ,MAGK;qCACQC,eAAT,CAAyBJ,UAAU3J,YAAY,CAAtB,CAAzB;;;6BAGC8F,QAAT,CAAkB+D,IAAlB;6BACS9D,MAAT;;;;;;;;;;;;;;;;;;gBAGA/F,YAAY2J,UAAU3I,MAA1B,EAAkC;;0BAEpBA,MAAV,GAAmBhB,SAAnB;qBACKqJ,KAAL,CAAWO,YAAYA,SAASzE,OAAhC;;;;;uCAGOlE,KAtKnB,EAsK0B;;;iBACbA,KAAL,GAAaA,KAAb;kBACMkI,IAAN,CAAW,UAAClB,CAAD,EAAO;oBACV,MAAKhH,KAAL,KAAeA,KAAnB,EAA0B;0BACjB6E,QAAL,CAAcmC,CAAd;0BACKlC,MAAL;;aAHR;;;;gCAO8B;gBAA5Bb,SAA4B,uEAAhB,KAAKA,SAAW;;wBAClB,KAAKA,SAAL,CAAe/C,UAA3B,EAAuC+C,UAAUvC,WAAjD,EAA8D,KAAKwC,OAAnE;;;;;;;;;;;;AAUR,IAAa6E,oBAAb;kCACgBnK,OAAZ,EAAqBwB,IAArB,EAA2BD,OAA3B,EAAoC;;;aAC3BH,KAAL,GAAa4C,SAAb;aACK+E,aAAL,GAAqB/E,SAArB;YACIzC,QAAQJ,MAAR,KAAmB,CAAnB,IAAwBI,QAAQ,CAAR,MAAe,EAAvC,IAA6CA,QAAQ,CAAR,MAAe,EAAhE,EAAoE;kBAC1D,IAAI6I,KAAJ,CAAU,yDAAV,CAAN;;aAECpK,OAAL,GAAeA,OAAf;aACKwB,IAAL,GAAYA,IAAZ;aACKD,OAAL,GAAeA,OAAf;;;;;iCAEKH,KAXb,EAWoB;iBACP2H,aAAL,GAAqB3H,KAArB;;;;iCAEK;mBACEqE,YAAY,KAAKsD,aAAjB,CAAP,EAAwC;oBAC9BF,eAAY,KAAKE,aAAvB;qBACKA,aAAL,GAAqBpD,QAArB;6BACU,IAAV;;gBAEA,KAAKoD,aAAL,KAAuBpD,QAA3B,EAAqC;;;gBAG/BvE,QAAQ,CAAC,CAAC,KAAK2H,aAArB;gBACI,KAAK3H,KAAL,KAAeA,KAAnB,EAA0B;oBAClBA,KAAJ,EAAW;yBACFpB,OAAL,CAAaJ,YAAb,CAA0B,KAAK4B,IAA/B,EAAqC,EAArC;iBADJ,MAGK;yBACIxB,OAAL,CAAakC,eAAb,CAA6B,KAAKV,IAAlC;;;iBAGHJ,KAAL,GAAaA,KAAb;iBACK2H,aAAL,GAAqBpD,QAArB;;;;;;;;;;;;;;AAYR,IAAa0E,iBAAb;;;+BACgBrK,OAAZ,EAAqBwB,IAArB,EAA2BD,OAA3B,EAAoC;;;0IAC1BvB,OAD0B,EACjBwB,IADiB,EACXD,OADW;;eAE3B+I,MAAL,GACK/I,QAAQJ,MAAR,KAAmB,CAAnB,IAAwBI,QAAQ,CAAR,MAAe,EAAvC,IAA6CA,QAAQ,CAAR,MAAe,EADjE;;;;;;sCAGU;mBACH,IAAIgJ,YAAJ,CAAiB,IAAjB,CAAP;;;;oCAEQ;gBACJ,KAAKD,MAAT,EAAiB;uBACN,KAAKrK,KAAL,CAAW,CAAX,EAAcmB,KAArB;;;;;;iCAIC;gBACD,KAAK4G,KAAT,EAAgB;qBACPA,KAAL,GAAa,KAAb;qBACKhI,OAAL,CAAa,KAAKwB,IAAlB,IAA0B,KAAKkH,SAAL,EAA1B;;;;;EAlB2BX,kBAAvC;AAsBA,IAAawC,YAAb;;;;;;;;;EAAkCrC,aAAlC;;;;;AAMA,IAAIsC,wBAAwB,KAA5B;AACA,IAAI;QACM1E,UAAU;YACR2E,OAAJ,GAAc;oCACc,IAAxB;mBACO,KAAP;;KAHR;WAMOC,gBAAP,CAAwB,MAAxB,EAAgC5E,OAAhC,EAAyCA,OAAzC;WACO6E,mBAAP,CAA2B,MAA3B,EAAmC7E,OAAnC,EAA4CA,OAA5C;CARJ,CAUA,OAAO8E,EAAP,EAAW;AAEX,IAAaC,SAAb;uBACgB7K,OAAZ,EAAqB8K,SAArB,EAAgCC,YAAhC,EAA8C;;;aACrC3J,KAAL,GAAa4C,SAAb;aACK+E,aAAL,GAAqB/E,SAArB;aACKhE,OAAL,GAAeA,OAAf;aACK8K,SAAL,GAAiBA,SAAjB;aACKC,YAAL,GAAoBA,YAApB;;;;;iCAEK3J,KARb,EAQoB;iBACP2H,aAAL,GAAqB3H,KAArB;;;;iCAEK;mBACEqE,YAAY,KAAKsD,aAAjB,CAAP,EAAwC;oBAC9BF,eAAY,KAAKE,aAAvB;qBACKA,aAAL,GAAqBpD,QAArB;6BACU,IAAV;;gBAEA,KAAKoD,aAAL,KAAuBpD,QAA3B,EAAqC;;;gBAG/BqF,cAAc,KAAKjC,aAAzB;gBACMkC,cAAc,KAAK7J,KAAzB;gBACM8J,uBAAuBF,eAAe,IAAf,IACzBC,eAAe,IAAf,KACKD,YAAYP,OAAZ,KAAwBQ,YAAYR,OAApC,IACGO,YAAYG,IAAZ,KAAqBF,YAAYE,IADpC,IAEGH,YAAYI,OAAZ,KAAwBH,YAAYG,OAH5C,CADJ;gBAKMC,oBAAoBL,eAAe,IAAf,KAAwBC,eAAe,IAAf,IAAuBC,oBAA/C,CAA1B;gBACIA,oBAAJ,EAA0B;qBACjBlL,OAAL,CAAa2K,mBAAb,CAAiC,KAAKG,SAAtC,EAAiD,IAAjD,EAAuD,KAAKQ,QAA5D;;iBAECA,QAAL,GAAgBC,WAAWP,WAAX,CAAhB;gBACIK,iBAAJ,EAAuB;qBACdrL,OAAL,CAAa0K,gBAAb,CAA8B,KAAKI,SAAnC,EAA8C,IAA9C,EAAoD,KAAKQ,QAAzD;;iBAEClK,KAAL,GAAa4J,WAAb;iBACKjC,aAAL,GAAqBpD,QAArB;;;;oCAEQ6F,KAtChB,EAsCuB;gBACTC,WAAY,OAAO,KAAKrK,KAAZ,KAAsB,UAAvB,GACb,KAAKA,KADQ,GAEZ,OAAO,KAAKA,KAAL,CAAWsK,WAAlB,KAAkC,UAAnC,GACI,KAAKtK,KAAL,CAAWsK,WADf,GAEI;uBAAM,IAAN;aAJR;qBAKSC,IAAT,CAAc,KAAKZ,YAAL,IAAqB,KAAK/K,OAAxC,EAAiDwL,KAAjD;;;;;;;;AAMR,IAAMD,aAAa,SAAbA,UAAa,CAAC7F,CAAD;WAAOA,MACrB8E,wBACG,EAAEC,SAAS/E,EAAE+E,OAAb,EAAsBW,SAAS1F,EAAE0F,OAAjC,EAA0CD,MAAMzF,EAAEyF,IAAlD,EADH,GAEGzF,EAAE+E,OAHgB,CAAP;CAAnB;;ACtaA;;;;;;;;;;;;;AAaA,AACA;;;;AAIA,AAAO,SAASf,eAAT,CAAyB3J,MAAzB,EAAiC;QAChC6L,gBAAgBC,eAAeC,GAAf,CAAmB/L,OAAOkC,IAA1B,CAApB;QACI2J,kBAAkB5H,SAAtB,EAAiC;wBACb,IAAI+H,GAAJ,EAAhB;uBACeC,GAAf,CAAmBjM,OAAOkC,IAA1B,EAAgC2J,aAAhC;;QAEAtL,WAAWsL,cAAcE,GAAd,CAAkB/L,OAAOwB,OAAzB,CAAf;QACIjB,aAAa0D,SAAjB,EAA4B;mBACb,IAAIlE,QAAJ,CAAaC,MAAb,EAAqBA,OAAOkM,kBAAP,EAArB,CAAX;sBACcD,GAAd,CAAkBjM,OAAOwB,OAAzB,EAAkCjB,QAAlC;;WAEGA,QAAP;;;;;AAKJ,AAAO,IAAMuL,iBAAiB,IAAIE,GAAJ,EAAvB;;AClCP;;;;;;;;;;;;;AAaA,AAGO,IAAM9L,QAAQ,IAAIuF,OAAJ,EAAd;;;;;;;;;;;;;;;;AAgBP,AAAO,IAAM0G,SAAS,SAATA,MAAS,CAACnM,MAAD,EAASiF,SAAT,EAAoBc,OAApB,EAAgC;MAC9C5C,OAAOjD,MAAM6L,GAAN,CAAU9G,SAAV,CAAX;MACI9B,SAASc,SAAb,EAAwB;gBACRgB,SAAZ,EAAuBA,UAAU6C,UAAjC;UACMmE,GAAN,CAAUhH,SAAV,EAAqB9B,OAAO,IAAI4F,QAAJ,CAAaqD,OAAOC,MAAP,CAAc,EAAE1C,gCAAF,EAAd,EAAmC5D,OAAnC,CAAb,CAA5B;SACKuG,UAAL,CAAgBrH,SAAhB;;OAECiB,QAAL,CAAclG,MAAd;OACKmG,MAAL;CARG;;AChCP;;;;;;;;;;;;;AAaA,AACA;;;AAGA,IAAaoG,wBAAb;;;;;;;;;;;;;;;;;mDAU+BtM,OAV/B,EAUwCwB,IAVxC,EAU8CD,OAV9C,EAUuDuE,OAVvD,EAUgE;gBAClDyG,SAAS/K,KAAK,CAAL,CAAf;gBACI+K,WAAW,GAAf,EAAoB;oBACV5D,YAAW,IAAI0B,iBAAJ,CAAsBrK,OAAtB,EAA+BwB,KAAKpC,KAAL,CAAW,CAAX,CAA/B,EAA8CmC,OAA9C,CAAjB;uBACOoH,UAAS1I,KAAhB;;gBAEAsM,WAAW,GAAf,EAAoB;uBACT,CAAC,IAAI1B,SAAJ,CAAc7K,OAAd,EAAuBwB,KAAKpC,KAAL,CAAW,CAAX,CAAvB,EAAsC0G,QAAQiF,YAA9C,CAAD,CAAP;;gBAEAwB,WAAW,GAAf,EAAoB;uBACT,CAAC,IAAIpC,oBAAJ,CAAyBnK,OAAzB,EAAkCwB,KAAKpC,KAAL,CAAW,CAAX,CAAlC,EAAiDmC,OAAjD,CAAD,CAAP;;gBAEEoH,WAAW,IAAIZ,kBAAJ,CAAuB/H,OAAvB,EAAgCwB,IAAhC,EAAsCD,OAAtC,CAAjB;mBACOoH,SAAS1I,KAAhB;;;;;;;;;6CAMiB6F,OA7BzB,EA6BkC;mBACnB,IAAIgD,QAAJ,CAAahD,OAAb,CAAP;;;;;AAGR,AAAO,IAAM0G,2BAA2B,IAAIF,wBAAJ,EAAjC;;AClDP;;;;;;;;;;;;;AAaA,AAYA;;;;AAIA,AAAO,IAAMvF,OAAO,SAAPA,IAAO,CAACxF,OAAD;oCAAayE,MAAb;UAAA;;;SAAwB,IAAIa,cAAJ,CAAmBtF,OAAnB,EAA4ByE,MAA5B,EAAoC,MAApC,EAA4CwG,wBAA5C,CAAxB;CAAb;;;;;;AC7BP;;;;;;;;;;;;;AAaA,AAMA;AACA,IAAMC,sBAAsB,SAAtBA,mBAAsB,CAACxK,IAAD,EAAOyK,SAAP;WAAwBzK,IAAxB,UAAiCyK,SAAjC;CAA5B;AACA,IAAIC,4BAA4B,IAAhC;AACA,IAAI,OAAO/H,OAAOgI,QAAd,KAA2B,WAA/B,EAA4C;gCACZ,KAA5B;CADJ,MAGK,IAAI,OAAOhI,OAAOgI,QAAP,CAAgBC,kBAAvB,KAA8C,WAAlD,EAA+D;YACxDC,IAAR,CAAa,mJAAb;gCAG4B,KAA5B;;;;;;AAMJ,IAAMC,uBAAuB,SAAvBA,oBAAuB,CAACL,SAAD;WAAe,UAAC3M,MAAD,EAAY;YAC9CiN,WAAWP,oBAAoB1M,OAAOkC,IAA3B,EAAiCyK,SAAjC,CAAjB;YACId,gBAAgBC,eAAeC,GAAf,CAAmBkB,QAAnB,CAApB;YACIpB,kBAAkB5H,SAAtB,EAAiC;4BACb,IAAI+H,GAAJ,EAAhB;2BACeC,GAAf,CAAmBgB,QAAnB,EAA6BpB,aAA7B;;YAEAtL,WAAWsL,cAAcE,GAAd,CAAkB/L,OAAOwB,OAAzB,CAAf;YACIjB,aAAa0D,SAAjB,EAA4B;gBAClBhE,UAAUD,OAAOkM,kBAAP,EAAhB;gBACIU,yBAAJ,EAA+B;uBACpBC,QAAP,CAAgBC,kBAAhB,CAAmC7M,OAAnC,EAA4C0M,SAA5C;;uBAEO,IAAI5M,QAAJ,CAAaC,MAAb,EAAqBC,OAArB,CAAX;0BACcgM,GAAd,CAAkBjM,OAAOwB,OAAzB,EAAkCjB,QAAlC;;eAEGA,QAAP;KAhByB;CAA7B;AAkBA,IAAM2M,iBAAiB,CAAC,MAAD,EAAS,KAAT,CAAvB;;;;AAIA,IAAMC,+BAA+B,SAA/BA,4BAA+B,CAACR,SAAD,EAAe;mBACjCzI,OAAf,CAAuB,UAAChC,IAAD,EAAU;YACvBkL,YAAYtB,eAAeC,GAAf,CAAmBW,oBAAoBxK,IAApB,EAA0ByK,SAA1B,CAAnB,CAAlB;YACIS,cAAcnJ,SAAlB,EAA6B;sBACfC,OAAV,CAAkB,UAAC3D,QAAD,EAAc;oBACTC,OADS,GACKD,QADL,CACpBN,OADoB,CACTO,OADS;;;oBAGtB6M,SAAS,IAAIC,GAAJ,EAAf;sBACMC,IAAN,CAAW/M,QAAQgN,gBAAR,CAAyB,OAAzB,CAAX,EAA8CtJ,OAA9C,CAAsD,UAACgD,CAAD,EAAO;2BAClDuG,GAAP,CAAWvG,CAAX;iBADJ;wCAGwB3G,QAAxB,EAAkC8M,MAAlC;aAPJ;;KAHR;CADJ;AAgBA,IAAMK,iBAAiB,IAAIJ,GAAJ,EAAvB;;;;;;;;;;;;;;;AAeA,IAAMK,wBAAwB,SAAxBA,qBAAwB,CAACC,WAAD,EAAcrN,QAAd,EAAwBoM,SAAxB,EAAsC;mBACjDc,GAAf,CAAmBd,SAAnB;;QAEMU,SAASO,YAAYJ,gBAAZ,CAA6B,OAA7B,CAAf;;QAEIH,OAAOjM,MAAP,KAAkB,CAAtB,EAAyB;;;QAGnByM,iBAAiBlO,SAASC,aAAT,CAAuB,OAAvB,CAAvB;;;;;;SAMK,IAAIuB,IAAI,CAAb,EAAgBA,IAAIkM,OAAOjM,MAA3B,EAAmCD,GAAnC,EAAwC;YAC9B2M,QAAQT,OAAOlM,CAAP,CAAd;cACMoB,UAAN,CAAiBU,WAAjB,CAA6B6K,KAA7B;uBACepE,WAAf,IAA8BoE,MAAMpE,WAApC;;;iCAGyBiD,SAA7B;;;2BAGuBpM,QAAvB,EAAiCsN,cAAjC,EAAiDtN,SAASN,OAAT,CAAiBO,OAAjB,CAAyBsH,UAA1E;;;;WAIO+E,QAAP,CAAgBc,qBAAhB,CAAsCpN,SAASN,OAA/C,EAAwD0M,SAAxD;QACI9H,OAAOgI,QAAP,CAAgBkB,YAApB,EAAkC;;;YAGxBD,SAAQvN,SAASN,OAAT,CAAiBO,OAAjB,CAAyBwN,aAAzB,CAAuC,OAAvC,CAAd;oBACYvL,YAAZ,CAAyBqL,OAAMzH,SAAN,CAAgB,IAAhB,CAAzB,EAAgDuH,YAAY9F,UAA5D;KAJJ,MAMK;;;;;;;iBAOQ7H,OAAT,CAAiBO,OAAjB,CAAyBiC,YAAzB,CAAsCoL,cAAtC,EAAsDtN,SAASN,OAAT,CAAiBO,OAAjB,CAAyBsH,UAA/E;YACMmG,UAAU,IAAIX,GAAJ,EAAhB;gBACQG,GAAR,CAAYI,cAAZ;gCACwBtN,QAAxB,EAAkC0N,OAAlC;;CA5CR;AA+CA,AAAO,IAAM9B,WAAS,SAATA,SAAS,CAACnM,MAAD,EAASiF,SAAT,EAAoBc,OAApB,EAAgC;QAC5C4G,YAAY5G,QAAQ4G,SAA1B;QACMuB,cAAchO,MAAM8D,GAAN,CAAUiB,SAAV,CAApB;WACUjF,MAAV,EAAkBiF,SAAlB,EAA6BmH,OAAOC,MAAP,CAAc,EAAE1C,iBAAiBqD,qBAAqBL,SAArB,CAAnB,EAAd,EAAoE5G,OAApE,CAA7B;;QAEId,qBAAqBkJ,UAArB,IAAmCvB,yBAAnC,IACA5M,kBAAkB8G,cADtB,EACsC;;YAE9B,CAAC4G,eAAe1J,GAAf,CAAmB2I,SAAnB,CAAL,EAAoC;gBAC1BxJ,OAAOjD,MAAM6L,GAAN,CAAU9G,SAAV,CAAb;gBACM4E,WAAW1G,KAAK9B,KAAtB;kCACsB4D,SAAtB,EAAiC4E,SAAStJ,QAA1C,EAAoDoM,SAApD;;;YAGA,CAACuB,WAAL,EAAkB;mBACPrB,QAAP,CAAgBuB,YAAhB,CAA6BnJ,UAAUoJ,IAAvC;;;CAfL;;AC3GP;AACA,IAAMC,MAAM9F,OAAO,KAAP,CAAZ;;;AAGA,IAAM+F,cAAc/F,OAAO,aAAP,CAApB;;;AAGA,IAAMgG,eAAe,SAAfA,YAAe;SAASC,MAAMpH,OAAN,CAAc,yCAAd,EAAyD,OAAzD,EAAkEvF,WAAlE,EAAT;CAArB;;;AAGA,IAAM4M,gBAAgB,SAAhBA,aAAgB,UAAW;UACvBC,CAAR,GAAY,EAAZ;UACQC,UAAR,CAAmBpB,gBAAnB,CAAoC,MAApC,EAA4CtJ,OAA5C,CAAoD,gBAAQ;YAClDyK,CAAR,CAAU7N,KAAK+N,EAAf,IAAqB/N,IAArB;GADF;CAFF;;;;;;;;;;;AAgBA,IAAagO,YAAb;;;0BACgB;;;;;UAEPF,UAAL,GAAkB,MAAKG,gBAAL,EAAlB;;;;WAIOC,mBAAP,QAAiC9K,OAAjC,CAAyC,oBAAY;UAC7C+K,gBAAgB,MAAKC,QAAL,CAAtB;aACO,MAAKA,QAAL,CAAP;YACKA,QAAL,IAAiBD,aAAjB;KAHF;;;;;;;;;;;;;uCAaiB;aACV,KAAKE,YAAL,CAAkB,EAAEC,MAAM,MAAR,EAAlB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;wCAyBkB;UACd,cAAc,IAAlB,EAAwB;aACjBjD,MAAL,CAAY,EAAEkD,MAAM,IAAR,EAAZ;sBACc,IAAd;;;;;;;;;;;;;;;;;wFAY4B,EA7DlC;+BA6DiBA,IA7DjB;YA6DiBA,IA7DjB,8BA6DwB,KA7DxB;;;;;;qBA8DSd,WAAL,IAAoB,IAApB;;oBACKc,IA/DT;;;;;;uBAgEY,CAhEZ;;;oBAkEQ,KAAKd,WAAL,CAAJ,EAAuB;uBAChBA,WAAL,IAAoB,KAApB;2BACO,KAAKhO,QAAZ,EAAsB,KAAKqO,UAA3B,EAAuC,EAAEjC,WAAW,KAAK2C,WAAL,CAAiBC,EAA9B,EAAkCvE,cAAc,IAAhD,EAAvC;;;;;;;;;;;;;;;;;;;2BArCY;aACN,KAAKwE,cAAL,CAAoBlB,GAApB,KAA4B,KAAKA,GAAL,CAA7B,KAA4C,KAAKA,GAAL,IAAYE,aAAa,KAAK/M,IAAlB,CAAxD,CAAP;;;;EAhC8BgO,WAAlC;;;;;;;;;;;"}