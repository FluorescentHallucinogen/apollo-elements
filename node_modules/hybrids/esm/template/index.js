import defineElements from '../define';
import { compile, getPlaceholder } from './core';
import resolve from './resolve';
var PLACEHOLDER = getPlaceholder();
var templatesMap = new Map();
var stylesMap = new WeakMap();
var helpers = {
  define: function define(elements) {
    defineElements(elements);
    return this;
  },
  key: function key(id) {
    this.id = id;
    return this;
  },
  style: function style() {
    for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
      styles[_key] = arguments[_key];
    }

    stylesMap.set(this, styles);
    return this;
  }
};

function create(parts, args, isSVG) {
  var fn = function fn(host) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : host;
    var styles = stylesMap.get(fn);
    var id = "".concat(parts.join(PLACEHOLDER)).concat(styles ? styles.join(PLACEHOLDER) : '').concat(isSVG ? 'svg' : '');
    var render = templatesMap.get(id);

    if (!render) {
      render = compile(parts, isSVG, styles);
      templatesMap.set(id, render);
    }

    render(host, target, args);
  };

  return Object.assign(fn, helpers);
}

export function html(parts) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return create(parts, args);
}
export function svg(parts) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return create(parts, args, true);
}
Object.assign(html, {
  resolve: resolve
});
Object.assign(svg, {
  resolve: resolve
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZW1wbGF0ZS9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZpbmVFbGVtZW50cyIsImNvbXBpbGUiLCJnZXRQbGFjZWhvbGRlciIsInJlc29sdmUiLCJQTEFDRUhPTERFUiIsInRlbXBsYXRlc01hcCIsIk1hcCIsInN0eWxlc01hcCIsIldlYWtNYXAiLCJoZWxwZXJzIiwiZGVmaW5lIiwiZWxlbWVudHMiLCJrZXkiLCJpZCIsInN0eWxlIiwic3R5bGVzIiwic2V0IiwiY3JlYXRlIiwicGFydHMiLCJhcmdzIiwiaXNTVkciLCJmbiIsImhvc3QiLCJ0YXJnZXQiLCJnZXQiLCJqb2luIiwicmVuZGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiaHRtbCIsInN2ZyJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBT0EsY0FBUCxNQUEyQixXQUEzQjtBQUVBLFNBQVNDLE9BQVQsRUFBa0JDLGNBQWxCLFFBQXdDLFFBQXhDO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixXQUFwQjtBQUVBLElBQU1DLFdBQVcsR0FBR0YsY0FBYyxFQUFsQztBQUVBLElBQU1HLFlBQVksR0FBRyxJQUFJQyxHQUFKLEVBQXJCO0FBQ0EsSUFBTUMsU0FBUyxHQUFHLElBQUlDLE9BQUosRUFBbEI7QUFFQSxJQUFNQyxPQUFPLEdBQUc7QUFDZEMsRUFBQUEsTUFEYyxrQkFDUEMsUUFETyxFQUNHO0FBQ2ZYLElBQUFBLGNBQWMsQ0FBQ1csUUFBRCxDQUFkO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0FKYTtBQUtkQyxFQUFBQSxHQUxjLGVBS1ZDLEVBTFUsRUFLTjtBQUNOLFNBQUtBLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFdBQU8sSUFBUDtBQUNELEdBUmE7QUFTZEMsRUFBQUEsS0FUYyxtQkFTRztBQUFBLHNDQUFSQyxNQUFRO0FBQVJBLE1BQUFBLE1BQVE7QUFBQTs7QUFDZlIsSUFBQUEsU0FBUyxDQUFDUyxHQUFWLENBQWMsSUFBZCxFQUFvQkQsTUFBcEI7QUFDQSxXQUFPLElBQVA7QUFDRDtBQVphLENBQWhCOztBQWVBLFNBQVNFLE1BQVQsQ0FBZ0JDLEtBQWhCLEVBQXVCQyxJQUF2QixFQUE2QkMsS0FBN0IsRUFBb0M7QUFDbEMsTUFBTUMsRUFBRSxHQUFHLFNBQUxBLEVBQUssQ0FBQ0MsSUFBRCxFQUF5QjtBQUFBLFFBQWxCQyxNQUFrQix1RUFBVEQsSUFBUztBQUNsQyxRQUFNUCxNQUFNLEdBQUdSLFNBQVMsQ0FBQ2lCLEdBQVYsQ0FBY0gsRUFBZCxDQUFmO0FBQ0EsUUFBTVIsRUFBRSxhQUFNSyxLQUFLLENBQUNPLElBQU4sQ0FBV3JCLFdBQVgsQ0FBTixTQUFnQ1csTUFBTSxHQUFHQSxNQUFNLENBQUNVLElBQVAsQ0FBWXJCLFdBQVosQ0FBSCxHQUE4QixFQUFwRSxTQUF5RWdCLEtBQUssR0FBRyxLQUFILEdBQVcsRUFBekYsQ0FBUjtBQUVBLFFBQUlNLE1BQU0sR0FBR3JCLFlBQVksQ0FBQ21CLEdBQWIsQ0FBaUJYLEVBQWpCLENBQWI7O0FBQ0EsUUFBSSxDQUFDYSxNQUFMLEVBQWE7QUFDWEEsTUFBQUEsTUFBTSxHQUFHekIsT0FBTyxDQUFDaUIsS0FBRCxFQUFRRSxLQUFSLEVBQWVMLE1BQWYsQ0FBaEI7QUFDQVYsTUFBQUEsWUFBWSxDQUFDVyxHQUFiLENBQWlCSCxFQUFqQixFQUFxQmEsTUFBckI7QUFDRDs7QUFFREEsSUFBQUEsTUFBTSxDQUFDSixJQUFELEVBQU9DLE1BQVAsRUFBZUosSUFBZixDQUFOO0FBQ0QsR0FYRDs7QUFhQSxTQUFPUSxNQUFNLENBQUNDLE1BQVAsQ0FBY1AsRUFBZCxFQUFrQlosT0FBbEIsQ0FBUDtBQUNEOztBQUVELE9BQU8sU0FBU29CLElBQVQsQ0FBY1gsS0FBZCxFQUE4QjtBQUFBLHFDQUFOQyxJQUFNO0FBQU5BLElBQUFBLElBQU07QUFBQTs7QUFDbkMsU0FBT0YsTUFBTSxDQUFDQyxLQUFELEVBQVFDLElBQVIsQ0FBYjtBQUNEO0FBRUQsT0FBTyxTQUFTVyxHQUFULENBQWFaLEtBQWIsRUFBNkI7QUFBQSxxQ0FBTkMsSUFBTTtBQUFOQSxJQUFBQSxJQUFNO0FBQUE7O0FBQ2xDLFNBQU9GLE1BQU0sQ0FBQ0MsS0FBRCxFQUFRQyxJQUFSLEVBQWMsSUFBZCxDQUFiO0FBQ0Q7QUFFRFEsTUFBTSxDQUFDQyxNQUFQLENBQWNDLElBQWQsRUFBb0I7QUFBRTFCLEVBQUFBLE9BQU8sRUFBUEE7QUFBRixDQUFwQjtBQUNBd0IsTUFBTSxDQUFDQyxNQUFQLENBQWNFLEdBQWQsRUFBbUI7QUFBRTNCLEVBQUFBLE9BQU8sRUFBUEE7QUFBRixDQUFuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWZpbmVFbGVtZW50cyBmcm9tICcuLi9kZWZpbmUnO1xuXG5pbXBvcnQgeyBjb21waWxlLCBnZXRQbGFjZWhvbGRlciB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgcmVzb2x2ZSBmcm9tICcuL3Jlc29sdmUnO1xuXG5jb25zdCBQTEFDRUhPTERFUiA9IGdldFBsYWNlaG9sZGVyKCk7XG5cbmNvbnN0IHRlbXBsYXRlc01hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IHN0eWxlc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IGhlbHBlcnMgPSB7XG4gIGRlZmluZShlbGVtZW50cykge1xuICAgIGRlZmluZUVsZW1lbnRzKGVsZW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAga2V5KGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHlsZSguLi5zdHlsZXMpIHtcbiAgICBzdHlsZXNNYXAuc2V0KHRoaXMsIHN0eWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGUocGFydHMsIGFyZ3MsIGlzU1ZHKSB7XG4gIGNvbnN0IGZuID0gKGhvc3QsIHRhcmdldCA9IGhvc3QpID0+IHtcbiAgICBjb25zdCBzdHlsZXMgPSBzdHlsZXNNYXAuZ2V0KGZuKTtcbiAgICBjb25zdCBpZCA9IGAke3BhcnRzLmpvaW4oUExBQ0VIT0xERVIpfSR7c3R5bGVzID8gc3R5bGVzLmpvaW4oUExBQ0VIT0xERVIpIDogJyd9JHtpc1NWRyA/ICdzdmcnIDogJyd9YDtcblxuICAgIGxldCByZW5kZXIgPSB0ZW1wbGF0ZXNNYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlbmRlcikge1xuICAgICAgcmVuZGVyID0gY29tcGlsZShwYXJ0cywgaXNTVkcsIHN0eWxlcyk7XG4gICAgICB0ZW1wbGF0ZXNNYXAuc2V0KGlkLCByZW5kZXIpO1xuICAgIH1cblxuICAgIHJlbmRlcihob3N0LCB0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCBoZWxwZXJzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh0bWwocGFydHMsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGNyZWF0ZShwYXJ0cywgYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdmcocGFydHMsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGNyZWF0ZShwYXJ0cywgYXJncywgdHJ1ZSk7XG59XG5cbk9iamVjdC5hc3NpZ24oaHRtbCwgeyByZXNvbHZlIH0pO1xuT2JqZWN0LmFzc2lnbihzdmcsIHsgcmVzb2x2ZSB9KTtcbiJdfQ==